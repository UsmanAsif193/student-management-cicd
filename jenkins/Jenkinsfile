pipeline {
  agent any

  options {
    disableConcurrentBuilds()
    timestamps()
  }

  environment {
    DOCKERHUB_CREDENTIALS = credentials('dockerhub-credentials')
    DOCKERHUB_USERNAME    = 'usmanasif193'
    IMAGE_NAME            = 'student-management-system'
    IMAGE_TAG             = "${BUILD_NUMBER}"
    FULL_IMAGE_NAME       = "${DOCKERHUB_USERNAME}/${IMAGE_NAME}:${IMAGE_TAG}"
    LATEST_IMAGE_NAME     = "${DOCKERHUB_USERNAME}/${IMAGE_NAME}:latest"

    // Monitoring NodePorts (match your current cluster)
    GRAFANA_NODEPORT      = "32000"
    PROM_NODEPORT         = "32001"
    MON_NAMESPACE         = "monitoring"
  }

  stages {

    // ==========================================
    // STAGE 1: CODE FETCH (6 Marks)
    // ==========================================
    stage('Code Fetch from GitHub') {
      steps {
        echo 'üì• Stage 1: Fetching code from GitHub...'
        sh '''
          echo "‚úÖ Workspace: $(pwd)"
          echo "‚úÖ Git info:"
          git rev-parse --short HEAD || true
          git log -1 --oneline || true
          echo "‚úÖ Files:"
          ls -la
        '''
      }
    }

    // ==========================================
    // STAGE 2: DOCKER IMAGE CREATION (10 Marks)
    // ==========================================
    stage('Build Docker Image') {
      steps {
        echo "üî® Stage 2: Building Docker image: ${FULL_IMAGE_NAME}"
        dir('app') {
          sh """
            docker build -t ${FULL_IMAGE_NAME} -f ../docker/Dockerfile .
            docker tag ${FULL_IMAGE_NAME} ${LATEST_IMAGE_NAME}
          """
        }
      }
    }

    stage('Push to DockerHub') {
      steps {
        echo "üì§ Stage 2: Pushing images to DockerHub..."
        sh """
          echo \$DOCKERHUB_CREDENTIALS_PSW | docker login -u \$DOCKERHUB_CREDENTIALS_USR --password-stdin
          docker push ${FULL_IMAGE_NAME}
          docker push ${LATEST_IMAGE_NAME}
          docker logout
        """
      }
    }

    stage('Docker Cleanup') {
      steps {
        echo "üßπ Cleaning local Docker images..."
        sh """
          docker rmi ${FULL_IMAGE_NAME} || true
          docker rmi ${LATEST_IMAGE_NAME} || true
        """
      }
    }

    // ==========================================
    // STAGE 3: KUBERNETES DEPLOYMENT (17 Marks)
    // ==========================================
    stage('Deploy to Kubernetes') {
      steps {
        echo "üöÄ Stage 3: Deploying to Kubernetes using image: ${LATEST_IMAGE_NAME}"

        sh '''
          echo "‚úÖ K8s connectivity check:"
          kubectl version --client=true
          kubectl config current-context
          kubectl get nodes -o wide
        '''

        // Update image in deployment file (safer sed: only replace the line that contains image:)
        sh """
          echo 'üìù Updating deployment image...'
          sed -i 's|^\\(\\s*image:\\s*\\).*|\\1${LATEST_IMAGE_NAME}|' kubernetes/app-deployment.yaml
          grep -n 'image:' kubernetes/app-deployment.yaml || true
        """

        sh """
          echo 'üîß Applying Kubernetes manifests...'

          kubectl apply -f kubernetes/postgres-config.yaml
          kubectl apply -f kubernetes/postgres-pvc.yaml
          kubectl apply -f kubernetes/postgres-deployment.yaml

          echo '‚è≥ Waiting for PostgreSQL...'
          kubectl wait --for=condition=ready pod -l app=postgres --timeout=180s || true

          kubectl apply -f kubernetes/app-deployment.yaml
          kubectl apply -f kubernetes/app-service.yaml

          echo '‚è≥ Waiting for app...'
          kubectl wait --for=condition=ready pod -l app=student-app --timeout=180s || true

          echo '‚úÖ Kubernetes deployment completed'
        """
      }
    }

    stage('Verify Deployment') {
      steps {
        echo "‚úÖ Verifying deployment..."
        sh '''
          echo "üìä Deployments:"
          kubectl get deployments -o wide

          echo ""
          echo "üì¶ Pods:"
          kubectl get pods -o wide

          echo ""
          echo "üîå Services:"
          kubectl get svc -o wide

          echo ""
          echo "üíæ PVC:"
          kubectl get pvc -o wide || true
        '''
      }
    }

    // ==========================================
    // STAGE 4: PROMETHEUS / GRAFANA (17 Marks)
    // ==========================================
    stage('Monitoring (Prometheus + Grafana)') {
      steps {
        echo "üìä Stage 4: Ensuring Prometheus + Grafana are installed (idempotent)..."

        sh """
          set -e

          echo "üì¶ Adding Helm repos (safe)..."
          helm repo add prometheus-community https://prometheus-community.github.io/helm-charts >/dev/null 2>&1 || true
          helm repo add grafana https://grafana.github.io/helm-charts >/dev/null 2>&1 || true
          helm repo update

          echo "üìå Creating namespace if missing..."
          kubectl get ns ${MON_NAMESPACE} >/dev/null 2>&1 || kubectl create ns ${MON_NAMESPACE}

          echo "‚úÖ Prometheus: install only if not present..."
          if helm -n ${MON_NAMESPACE} status prometheus >/dev/null 2>&1; then
            echo "Prometheus already installed ‚úÖ"
          else
            helm upgrade --install prometheus prometheus-community/prometheus \\
              -n ${MON_NAMESPACE} --create-namespace \\
              --set server.service.type=NodePort \\
              --set server.service.nodePort=${PROM_NODEPORT} \\
              --set alertmanager.enabled=false \\
              --set pushgateway.enabled=false \\
              --set server.resources.requests.cpu=100m \\
              --set server.resources.requests.memory=256Mi \\
              --set server.resources.limits.memory=512Mi \\
              --wait --timeout=10m
          fi

          echo "‚úÖ Grafana: install only if not present..."
          if helm -n ${MON_NAMESPACE} status grafana >/dev/null 2>&1; then
            echo "Grafana already installed ‚úÖ"
          else
            helm upgrade --install grafana grafana/grafana \\
              -n ${MON_NAMESPACE} --create-namespace \\
              --set service.type=NodePort \\
              --set service.nodePort=${GRAFANA_NODEPORT} \\
              --set resources.requests.cpu=50m \\
              --set resources.requests.memory=128Mi \\
              --set resources.limits.memory=256Mi \\
              --wait --timeout=10m
          fi

          echo ""
          echo "üìå Monitoring Services:"
          kubectl -n ${MON_NAMESPACE} get svc -o wide

          echo ""
          echo "üîê Grafana Credentials:"
          echo "Username: admin"
          echo -n "Password: "
          kubectl -n ${MON_NAMESPACE} get secret grafana -o jsonpath="{.data.admin-password}" | base64 -d || true
          echo ""

          echo ""
          echo "‚úÖ ACCESS (replace <EC2-PUBLIC-IP>):"
          echo "Grafana:    http://<EC2-PUBLIC-IP>:${GRAFANA_NODEPORT}"
          echo "Prometheus: http://<EC2-PUBLIC-IP>:${PROM_NODEPORT}"
        """
      }
    }
  }

  post {
    success {
      echo "‚úÖ PIPELINE SUCCESS ‚Äî Image: ${LATEST_IMAGE_NAME}"
    }
    failure {
      echo "‚ùå PIPELINE FAILED ‚Äî check logs above."
    }
    always {
      cleanWs()
    }
  }
}
